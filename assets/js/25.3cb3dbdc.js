(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{392:function(n,t,e){"use strict";e.r(t);var r=e(48),o=Object(r.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"java-core"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#java-core"}},[n._v("#")]),n._v(" JAVA CORE")]),n._v(" "),e("h2",{attrs:{id:"_1"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1"}},[n._v("#")]),n._v(" 1.")]),n._v(" "),e("h2",{attrs:{id:"lombok-어노테이션"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#lombok-어노테이션"}},[n._v("#")]),n._v(" LOMBOK 어노테이션 !!")]),n._v(" "),e("p",[n._v("@Getter and @Setter  // @Getter(access = AccessLevel.PROOTECTED)\n@FieldNameConstants\n@ToString\n@EqualsAndHashCode\n@AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor\n@Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog, @Flogger, @CustomLog\n@Data\n@Builder\n@SuperBuilder\n@Singular\n@Delegate\n@Value\n@Accessors\n@Wither\n@With\n@SneakyThrows\n@val\n@var\nexperimental @var\n@UtilityClass\nLombok config system\nCode inspections\nRefactoring actions (lombok and delombok)")]),n._v(" "),e("h2",{attrs:{id:"https-goddaehee-tistory-com-208"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#https-goddaehee-tistory-com-208"}},[n._v("#")]),n._v(" "),e("a",{attrs:{href:"https://goddaehee.tistory.com/208",target:"_blank",rel:"noopener noreferrer"}},[n._v("https://goddaehee.tistory.com/208"),e("OutboundLink")],1)]),n._v(" "),e("p",[n._v("※ 롬복의 실무 적용 시에는 왠만하면 @Getter, @Setter, @ToString @Slf4j 등만 사용하길 권장하고 싶다.")]),n._v(" "),e("p",[n._v("@springBootApplication : 스프링컴포넌트 스캔 및 스프링 부트 자동 구성을 활성화 한다.\n@Controller : 업무 Controller 구현시 사용, 역할별 객체 생성 (@RequestMapping, @ResponseBody, @RequestBody)\n@Service : 업무 Service 구현시 사용, 역할 별 객체 생성\n@Repository : 업무 DAO 구현시 사용, 역할 별 객체 생성\n@Autowired : DI(Dependency Injection, 의존성 삽입)을 지원하며, 객체 초기화 시 연관된 객체를 삽입시킨다.\n@Mapper : DAO interface를 구현하지 않아도 SQL map xml을 호출해 준다. (단, DAO 패키지명과 SQL map xml의 네임스페이스가 동일해야 함)")]),n._v(" "),e("p",[n._v("이외 :@Component, @qualifier, @Resource 등의 여러 종류의 Annotation이 존재하며, 프로젝트 진행 중 추가적으로 유용한 Annotation을 검토하여 사용할 수 있다.\nDI: Dependency Injection(의존성 삽입), Spring IOC(Inversion of Control) Container에서 지원하는 runtime 시 객체 연관 참조 삽입 기술")]),n._v(" "),e("p",[n._v("[JAVA 어노테이션]\nhttps://nesoy.github.io/articles/2018-04/Java-Annotation")]),n._v(" "),e("p",[n._v("// 정리할 것\n"),e("a",{attrs:{href:"https://jaehun2841.github.io/2018/09/22/2018-09-21-spring-ioc-2/#servlet-contextxml",target:"_blank",rel:"noopener noreferrer"}},[n._v("https://jaehun2841.github.io/2018/09/22/2018-09-21-spring-ioc-2/#servlet-contextxml"),e("OutboundLink")],1)]),n._v(" "),e("p",[n._v("// 정리 , spring springboot 비교\n"),e("a",{attrs:{href:"https://ssoco.tistory.com/66",target:"_blank",rel:"noopener noreferrer"}},[n._v("https://ssoco.tistory.com/66"),e("OutboundLink")],1)]),n._v(" "),e("hr"),n._v(" "),e("p",[n._v("(스프링 버전별 특징)\nhttps://redbinalgorithm.tistory.com/589")]),n._v(" "),e("p",[n._v("Spring 3버전부터 5버전까지 사용해 보았지만 항상 최신버전을 사용해 왔었고 내가 하는 프로젝트내에서는 그차이를 느끼지 못했다.\n이번에 그차이점을 알고 그에 관련된 기능들을 사용해 보려고 한다.\n알고 있는 내용에 대해서는 예제를 안만들 것이고 사용해보지 않은 기능들을 다룰려고 합니다.")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("[Spring]\nSpring 3.2\n  Java 5의 기능 (제너릭, 가변 매개변수 등)을 사용하여 개정되었습니다.\n  이로 인해서 BeanFactory 등 핵심 API가 업데이트 되었습니다.\n  @Async 주석을 통해 비동기 메서드 호출을 지원하기 시작했습니다.\n  하나의 Spring.jar로 제공하던 것을 여러 Spring 모듈의 jar 파일로 나누어 제공하기 시작했습니다.\n  (Spring Core, Spring-web 등)\n  SPEL(Spring Expression Language)가 도입되어 XML 및 Annotation 기반 Bean 정의에서 사용할 수 있게 되었습니다.\n  환경설정 파일에서 값을 가져올 수 있게 되었습니다.\n  @configuration , @Bean 등을 이용해 메타 데이터를 설정 할 수 있습니다.\n  Bean을 XML 형태로 관리할 수 있습니다. OXM(Object Xml Mapping)\n  REST API\n  Annotation 기반 확장 기술\n  RestTemplate 지원 합니다.\n  H2 지원\n  2016년 12월 31일 개발 및 지원 중단됩니다.\n\nSpring 4.3\n  Java 8 기능을 완전히 지원하기 시작했습니다.\n  Java 6, Java 7 의 고유 기능 지원합니다.\n  Starter Pack의 등장으로 초기 설정이 수월해졌습니다.\n  Groovy를 통한 Bean 설정이 가능하다.\n  Core Container 들의 기능 지원이 확대되었다.\n  커스텀 어노테이션, 메타 어노테이션 지원\n  @Oreder 어노테이션을 통해 배열과 리스트 형태의 Bean 을 정렬 할 수 있습니다.\n  @Lazy 어노테이션을 통해 Lazy Injection이 가능하다.\n  @RestController 지원\n  WebSocekt STOMP 등의 프로토콜을 지원\n  Framework 레벨에서 테스트 유틸리티를 지원합니다.\n  2020년 12월 31일 개발 및 지원 종료\n\nSpring 5.x\n  제너릭 , 람다 가독성 향상되었습니다.\n  JDK 9 와도 호환이 가능합니다.\n  Jackson2.9 , Protobuf3 , Reactor3.1 과의 호환 추가\n  Spring WebFlux 추가, 비동기와 넌-블로킹 이벤트 루프 모델 사용 가능\n  Kotlin 지원\n  [Junit 5]지원\n  Spring 5.1\n  2021년 말까지 지원\n  Spring 5.2\n  2021년 말까지 지원\n\n\n[Spring Boot]\nSpring Boot 1.1 (Release 2014.05)\n  Java 1.6 이상\n  Spring Framework 4.0.5\n  Tomcat 7.0.54, Hibernate 4.3.1\n  Spring Boot 1.5 (Release 2017.01)\n  Java 8 이상\n  Spring Framework 4.3\n  Tomcat 8.5, Hibernate 5.0\n  ConfigurationProperties 에 JSR303 지원\n  Spring Boot 2.0.0 (Release 2018.03)\n  Java 8 , Java 9 tested\n  Spring Framework 5.0\n  Tomcat 8.5, Hibernate 5.2\n\nSpring Boot 2.1.0(Release 2018.10)\n  Java 11 Support (Java 8 ~ 11)\n  Spring Framework 5.1\n  Tomcat 9, Hibernate 5.3\n\n\n")])])]),e("p",[n._v("(스프링 부트 사용 !! 정리)\nhttps://kgmyh.github.io/blog/2017/12/04/spring-boot-chapter03/")]),n._v(" "),e("p",[n._v("[JAVA JPA]\nhttps://brunch.co.kr/@springboot/595")]),n._v(" "),e("p",[n._v("[JDBC]\nhttps://brunch.co.kr/@springboot/105")])])}),[],!1,null,null,null);t.default=o.exports}}]);