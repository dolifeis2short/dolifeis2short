(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{383:function(t,a,n){"use strict";n.r(a);var s=n(48),i=Object(s.a)({},(function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"설계-원칙"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#설계-원칙"}},[t._v("#")]),t._v(" 설계 원칙")]),t._v(" "),n("ul",[n("li",[t._v("구축의 목표와, 그 목표를 효과적으로 달성하기 위한 전략과 방향")]),t._v(" "),n("li",[t._v("정보의 실체가 되는 산출물을 정의")])]),t._v(" "),n("div",{staticClass:"language-markdown extra-class"},[n("pre",{pre:!0,attrs:{class:"language-markdown"}},[n("code",[n("span",{pre:!0,attrs:{class:"token title important"}},[n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("##")]),t._v("**Public** : 흐름 (위임 메소드, 조합 메소드)")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token list punctuation"}},[t._v("-")]),t._v(" 구현에 대한 기술을 하지 않는다.\n\n"),n("span",{pre:!0,attrs:{class:"token title important"}},[n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("##")]),t._v("**Protected, Private**")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token list punctuation"}},[t._v("-")]),t._v(" 기술, 이야기의 의미를 서술한다.\n\n"),n("span",{pre:!0,attrs:{class:"token title important"}},[n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("##")]),t._v("**커뮤니케이션****은 Diagram")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token title important"}},[n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("##")]),t._v("**Class** 는 명사")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token title important"}},[n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("##")]),t._v("**Method**는 동사")]),t._v("\n")])])]),n("h2",{attrs:{id:"설계-레벨"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#설계-레벨"}},[t._v("#")]),t._v(" 설계 레벨")]),t._v(" "),n("h3",{attrs:{id:"_1-설계-수준"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-설계-수준"}},[t._v("#")]),t._v(" 1. 설계 수준")]),t._v(" "),n("ul",[n("li",[t._v("S/W 시스템 설계")]),t._v(" "),n("li",[t._v("Sub 시스템 설계")]),t._v(" "),n("li",[t._v("모듈 / 패키지 설계")]),t._v(" "),n("li",[t._v("컴포넌트 설계")]),t._v(" "),n("li",[t._v("클래스 분화 설계")]),t._v(" "),n("li",[t._v("루틴 분화 설계")])]),t._v(" "),n("h3",{attrs:{id:"_2-설계"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-설계"}},[t._v("#")]),t._v(" 2. 설계")]),t._v(" "),n("ul",[n("li",[t._v("반복 / 분할 정복 설계")]),t._v(" "),n("li",[t._v("상향 / 하향적 설계")]),t._v(" "),n("li",[t._v("프로토 타입 설계")]),t._v(" "),n("li",[t._v("협력적 설계")])]),t._v(" "),n("h3",{attrs:{id:"_3-루틴-응집-수준"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-루틴-응집-수준"}},[t._v("#")]),t._v(" 3. 루틴 응집 수준")]),t._v(" "),n("ul",[n("li",[t._v("우연한 응집")]),t._v(" "),n("li",[t._v("논리적 응집")]),t._v(" "),n("li",[t._v("시점 기준 응집")]),t._v(" "),n("li",[t._v("절차적 응집")]),t._v(" "),n("li",[t._v("소통적 응집")]),t._v(" "),n("li",[t._v("순차적 응집")]),t._v(" "),n("li",[t._v("기능적 응집 (단일 책임 원칙) !!!\n상속은 Has a (X)구조가 아닌 Is a (O) 구조")])]),t._v(" "),n("h2",{attrs:{id:"객체지향-설계"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#객체지향-설계"}},[t._v("#")]),t._v(" 객체지향 설계")]),t._v(" "),n("h3",{attrs:{id:"_1-객체지향-설계-5대-원칙-solid"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-객체지향-설계-5대-원칙-solid"}},[t._v("#")]),t._v(" 1. 객체지향 설계 5대 원칙 ( SOLID )")]),t._v(" "),n("ul",[n("li",[n("strong",[t._v("OCP")]),t._v(" : Open-Closed Principle (개방-폐쇄의 원칙)\n( “상속에는 열려있어야 하고 변경에는 닫혀있어야한다.” )")]),t._v(" "),n("li",[n("strong",[t._v("SRP")]),t._v(" : Single-Responsibility Principle (단일 책임의 원칙)")]),t._v(" "),n("li",[n("strong",[t._v("DIP")]),t._v(" : Dependency Inversion Principle (의존 역전의 원칙)")]),t._v(" "),n("li",[n("strong",[t._v("ISP")]),t._v(" : Interface Segregation Principle (인터페이스 분리의 원칙)")]),t._v(" "),n("li",[n("strong",[t._v("LSP")]),t._v(" : Liskov Substitution Principle (리스코프의 대체 원칙)")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("**SOLID 개념 정리**\n1. 단일 책임 원칙  Single Responsibility Principle\n    - 한가지 기능의 변경이 다른 곳에 영향을 주어서는 안된다.\n2. 개방 / 폐쇄 원칙  Open / Closed Principle\n    - 개체는 확장 가능성을 열어두고, 수정 가능성은 닫아야 한다. (Extend)\n3. 리스코프 치환 원칙 Liskov Substitution Principle\n    - 개체의 추상화 -어떤 타입에서 파생된 객체가 있다면 이 타입을 사용하는 코드는 변경하지 않아야한다.(abstract)\n4. 인터페이스 분리 원칙 Interface Segrefation Principle\n   - 외부 인터페이스를 통해서 객체끼리 소통한다.\n5. 의존성 역전 원칙 Dependency Inversion Principle\n   - 상위 수준 모듈은 하위 수준 모듈에 의존해서는 안된다. 이 둘읕 추상화에 의존해야 한다.\n\nDRY  규칙\n- 반복하지 마라. !! (Do not Repeat Yourself)\n")])])]),n("h3",{attrs:{id:"_2-객체지향-4대-원칙"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-객체지향-4대-원칙"}},[t._v("#")]),t._v(" 2. 객체지향 4대 원칙")]),t._v(" "),n("ul",[n("li",[t._v("캡슐화 (Encapsulation) - 정보 은닉")]),t._v(" "),n("li",[t._v("다형성 (Polymorphism) - 사용자 편의")]),t._v(" "),n("li",[t._v("상속 (Inheritance) - 재사용")]),t._v(" "),n("li",[t._v("추상화(Abstraction) - 모델링\n(상속을 통한 추상화, 인터페이스를 통한 추상화, 다형성을 추상화)")])]),t._v(" "),n("h3",{attrs:{id:"_3-solid-개념"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-solid-개념"}},[t._v("#")]),t._v(" 3. SOLID 개념")]),t._v(" "),n("ul",[n("li",[t._v("단일 책임 원칙 Single Responsibility Principle\n"),n("ul",[n("li",[t._v("한가지 기능의 변경이 다른 곳에 영향을 주어서는 안된다.")])])]),t._v(" "),n("li",[t._v("개방 / 폐쇄 원칙 Open / Closed Principle\n"),n("ul",[n("li",[t._v("개체는 확장 가능성을 열어두고, 수정 가능성은 닫아야 한다. (Extend)")])])]),t._v(" "),n("li",[t._v("리스코프 치환 원칙 Liskov Substitution Principle\n"),n("ul",[n("li",[t._v("개체의 추상화 - 어떤 타입에서 파생된 객체가 있다면 이 타입을 사용하는 코드는 변경하지 않아야 한다. (abstract)")])])]),t._v(" "),n("li",[t._v("인터페이스 분리 원칙 Interface Segrefation Principle\n"),n("ul",[n("li",[t._v("외부 인터페이스를 통해서 객체끼리 소통한다.")])])]),t._v(" "),n("li",[t._v("의존성 역전 원칙 Dependency Inversion Principle\n"),n("ul",[n("li",[t._v("상위 수준 모듈은 하위 수준 모듈에 의존해서는 안된다. 이 둘읕 추상화에 의존해야 한다.")])])])])])}),[],!1,null,null,null);a.default=i.exports}}]);