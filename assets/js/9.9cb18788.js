(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{374:function(t,n,i){"use strict";i.r(n);var a=i(48),e=Object(a.a)({},(function(){var t=this,n=t.$createElement,i=t._self._c||n;return i("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[i("h1",{attrs:{id:"설계이론"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#설계이론"}},[t._v("#")]),t._v(" 설계이론")]),t._v(" "),i("p",[t._v("개발 구축 목표와, 그 목표를 효과적으로 달성하기 위한 전략과 방향")]),t._v(" "),i("h2",{attrs:{id:"_1-설계-레벨"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_1-설계-레벨"}},[t._v("#")]),t._v(" 1. 설계 레벨")]),t._v(" "),i("h3",{attrs:{id:"설계-수준"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#설계-수준"}},[t._v("#")]),t._v(" 설계 수준")]),t._v(" "),i("ul",[i("li",[t._v("S/W 시스템 설계")]),t._v(" "),i("li",[t._v("Sub 시스템 설계")]),t._v(" "),i("li",[t._v("모듈 / 패키지 설계")]),t._v(" "),i("li",[t._v("컴포넌트 설계")]),t._v(" "),i("li",[t._v("클래스 분화 설계")]),t._v(" "),i("li",[t._v("루틴 분화 설계")])]),t._v(" "),i("div",{staticClass:"language-markdown extra-class"},[i("pre",{pre:!0,attrs:{class:"language-markdown"}},[i("code",[i("span",{pre:!0,attrs:{class:"token list punctuation"}},[t._v("*")]),t._v(" Public : 흐름 (위임 메소드, 조합 메소드)\n  "),i("span",{pre:!0,attrs:{class:"token list punctuation"}},[t._v("+")]),t._v(" 구현에 대한 기술을 하지 않는다.\n"),i("span",{pre:!0,attrs:{class:"token list punctuation"}},[t._v("*")]),t._v(" Protected, Private"),i("span",{pre:!0,attrs:{class:"token italic"}},[i("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("*")]),i("span",{pre:!0,attrs:{class:"token content"}},[t._v(" \n  + 기술, 이야기의 의미를 서술한다.\n")]),i("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("*")])]),t._v(" 커뮤니케이션 은 Diagram\n"),i("span",{pre:!0,attrs:{class:"token list punctuation"}},[t._v("*")]),t._v(" Class 는 명사\n"),i("span",{pre:!0,attrs:{class:"token list punctuation"}},[t._v("*")]),t._v(" Method 는 동사\n")])])]),i("h3",{attrs:{id:"설계-방식"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#설계-방식"}},[t._v("#")]),t._v(" 설계 방식")]),t._v(" "),i("ul",[i("li",[t._v("반복 / 분할 정복 설계")]),t._v(" "),i("li",[t._v("상향 / 하향적 설계")]),t._v(" "),i("li",[t._v("프로토 타입 설계")]),t._v(" "),i("li",[t._v("협력적 설계")])]),t._v(" "),i("h3",{attrs:{id:"루틴-응집-수준"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#루틴-응집-수준"}},[t._v("#")]),t._v(" 루틴 응집 수준")]),t._v(" "),i("ul",[i("li",[t._v("우연한 응집")]),t._v(" "),i("li",[t._v("논리적 응집")]),t._v(" "),i("li",[t._v("시점 기준 응집")]),t._v(" "),i("li",[t._v("절차적 응집")]),t._v(" "),i("li",[t._v("소통적 응집")]),t._v(" "),i("li",[t._v("순차적 응집")]),t._v(" "),i("li",[t._v("기능적 응집 (단일 책임 원칙) !!!")])]),t._v(" "),i("h3",{attrs:{id:"객체지향-설계-5대-원칙-solid"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#객체지향-설계-5대-원칙-solid"}},[t._v("#")]),t._v(" 객체지향 설계 5대 원칙 ( SOLID )")]),t._v(" "),i("ul",[i("li",[i("strong",[t._v("OCP")]),t._v(" : Open-Closed Principle (개방-폐쇄의 원칙)"),i("br"),t._v("\n( “상속에는 열려있어야 하고 변경에는 닫혀있어야한다.” )")]),t._v(" "),i("li",[i("strong",[t._v("SRP")]),t._v(" : Single-Responsibility Principle (단일 책임의 원칙)")]),t._v(" "),i("li",[i("strong",[t._v("DIP")]),t._v(" : Dependency Inversion Principle (의존 역전의 원칙)")]),t._v(" "),i("li",[i("strong",[t._v("ISP")]),t._v(" : Interface Segregation Principle (인터페이스 분리의 원칙)")]),t._v(" "),i("li",[i("strong",[t._v("LSP")]),t._v(" : Liskov Substitution Principle (리스코프의 대체 원칙)")])]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[t._v("**SOLID 개념 정리**\n1. 단일 책임 원칙  Single Responsibility Principle\n    - 한가지 기능의 변경이 다른 곳에 영향을 주어서는 안된다.\n2. 개방 / 폐쇄 원칙  Open / Closed Principle\n    - 개체는 확장 가능성을 열어두고, 수정 가능성은 닫아야 한다. (Extend)\n3. 리스코프 치환 원칙 Liskov Substitution Principle\n    - 개체의 추상화 -어떤 타입에서 파생된 객체가 있다면 이 타입을 사용하는 코드는 변경하지 않아야한다.(abstract)\n4. 인터페이스 분리 원칙 Interface Segrefation Principle\n   - 외부 인터페이스를 통해서 객체끼리 소통한다.\n5. 의존성 역전 원칙 Dependency Inversion Principle\n   - 상위 수준 모듈은 하위 수준 모듈에 의존해서는 안된다. 이 둘읕 추상화에 의존해야 한다.\n\nDRY  규칙\n- 반복하지 마라. !! (Do not Repeat Yourself)\n")])])]),i("h3",{attrs:{id:"객체지향-4대-원칙"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#객체지향-4대-원칙"}},[t._v("#")]),t._v(" 객체지향 4대 원칙")]),t._v(" "),i("ul",[i("li",[t._v("캡슐화 (Encapsulation) - 정보 은닉")]),t._v(" "),i("li",[t._v("다형성 (Polymorphism) - 사용자 편의")]),t._v(" "),i("li",[t._v("상속 (Inheritance) - 재사용")]),t._v(" "),i("li",[t._v("추상화(Abstraction) - 모델링\n(상속을 통한 추상화, 인터페이스를 통한 추상화, 다형성을 추상화)")])]),t._v(" "),i("h3",{attrs:{id:"solid-개념"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#solid-개념"}},[t._v("#")]),t._v(" SOLID 개념")]),t._v(" "),i("ul",[i("li",[t._v("단일 책임 원칙 Single Responsibility Principle"),i("br"),t._v("\n한가지 기능의 변경이 다른 곳에 영향을 주어서는 안된다.")]),t._v(" "),i("li",[t._v("개방 / 폐쇄 원칙 Open / Closed Principle"),i("br"),t._v("\n개체는 확장 가능성을 열어두고, 수정 가능성은 닫아야 한다. (Extend)")]),t._v(" "),i("li",[t._v("리스코프 치환 원칙 Liskov Substitution Principle"),i("br"),t._v("\n개체의 추상화 - 어떤 타입에서 파생된 객체가 있다면 이 타입을 사용하는 코드는 변경하지 않아야 한다. (abstract)")]),t._v(" "),i("li",[t._v("인터페이스 분리 원칙 Interface Segrefation Principle"),i("br"),t._v("\n외부 인터페이스를 통해서 객체끼리 소통한다.")]),t._v(" "),i("li",[t._v("의존성 역전 원칙 Dependency Inversion Principle"),i("br"),t._v("\n상위 수준 모듈은 하위 수준 모듈에 의존해서는 안된다. 이 둘읕 추상화에 의존해야 한다.")])]),t._v(" "),i("h2",{attrs:{id:"_2-uml"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_2-uml"}},[t._v("#")]),t._v(" 2. UML")]),t._v(" "),i("h3",{attrs:{id:"일반화"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#일반화"}},[t._v("#")]),t._v(" 일반화")]),t._v(" "),i("ul",[i("li",[t._v("Generalization (object -> extends)")]),t._v(" "),i("li",[t._v("Realization (interface -> implementation)")]),t._v(" "),i("li",[t._v("Dependency (Setter, return Object)\n"),i("ul",[i("li",[t._v("매서드 내에서 대상 클래스를 생성, 리턴 받아서 사용하는 것")]),t._v(" "),i("li",[t._v("해당 클래스와 관계를 유지하지 않음")])])]),t._v(" "),i("li",[t._v("Association ()\n"),i("ul",[i("li",[t._v("다른 객체의 참조를 가지는 필드")])])]),t._v(" "),i("li",[t._v("Aggregation / Composition\n"),i("ul",[i("li",[t._v("생명주기가 Object 종속")])])])])])}),[],!1,null,null,null);n.default=e.exports}}]);