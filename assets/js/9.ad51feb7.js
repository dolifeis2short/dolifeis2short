(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{376:function(i,l,n){"use strict";n.r(l);var t=n(48),_=Object(t.a)({},(function(){var i=this,l=i.$createElement,n=i._self._c||l;return n("ContentSlotsDistributor",{attrs:{"slot-key":i.$parent.slotKey}},[n("h2",{attrs:{id:"설계-원칙"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#설계-원칙"}},[i._v("#")]),i._v(" 설계 원칙")]),i._v(" "),n("ul",[n("li",[i._v("구축의 목표와, 그 목표를 효과적으로 달성하기 위한 전략과 방향")]),i._v(" "),n("li",[i._v("정보의 실체가 되는 산출물을 정의")])]),i._v(" "),n("div",{staticClass:"language-markdown extra-class"},[n("pre",{pre:!0,attrs:{class:"language-markdown"}},[n("code",[n("span",{pre:!0,attrs:{class:"token title important"}},[n("span",{pre:!0,attrs:{class:"token punctuation"}},[i._v("##")]),i._v("**Public** : 흐름 (위임 메소드, 조합 메소드)")]),i._v("\n"),n("span",{pre:!0,attrs:{class:"token list punctuation"}},[i._v("-")]),i._v(" 구현에 대한 기술을 하지 않는다.\n\n"),n("span",{pre:!0,attrs:{class:"token title important"}},[n("span",{pre:!0,attrs:{class:"token punctuation"}},[i._v("##")]),i._v("**Protected, Private**")]),i._v("\n"),n("span",{pre:!0,attrs:{class:"token list punctuation"}},[i._v("-")]),i._v(" 기술, 이야기의 의미를 서술한다.\n\n"),n("span",{pre:!0,attrs:{class:"token title important"}},[n("span",{pre:!0,attrs:{class:"token punctuation"}},[i._v("##")]),i._v("**커뮤니케이션****은 Diagram")]),i._v("\n\n"),n("span",{pre:!0,attrs:{class:"token title important"}},[n("span",{pre:!0,attrs:{class:"token punctuation"}},[i._v("##")]),i._v("**Class** 는 명사")]),i._v("\n"),n("span",{pre:!0,attrs:{class:"token title important"}},[n("span",{pre:!0,attrs:{class:"token punctuation"}},[i._v("##")]),i._v("**Method**는 동사")]),i._v("\n")])])]),n("h2",{attrs:{id:"설계-레벨"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#설계-레벨"}},[i._v("#")]),i._v(" 설계 레벨")]),i._v(" "),n("h3",{attrs:{id:"_1-설계-수준"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-설계-수준"}},[i._v("#")]),i._v(" 1. 설계 수준")]),i._v(" "),n("ul",[n("li",[i._v("S/W 시스템 설계")]),i._v(" "),n("li",[i._v("Sub 시스템 설계")]),i._v(" "),n("li",[i._v("모듈 / 패키지 설계")]),i._v(" "),n("li",[i._v("컴포넌트 설계")]),i._v(" "),n("li",[i._v("클래스 분화 설계")]),i._v(" "),n("li",[i._v("루틴 분화 설계")])]),i._v(" "),n("h3",{attrs:{id:"_2-설계"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-설계"}},[i._v("#")]),i._v(" 2. 설계")]),i._v(" "),n("ul",[n("li",[i._v("반복 / 분할 정복 설계")]),i._v(" "),n("li",[i._v("상향 / 하향적 설계")]),i._v(" "),n("li",[i._v("프로토 타입 설계")]),i._v(" "),n("li",[i._v("협력적 설계")])]),i._v(" "),n("h3",{attrs:{id:"_3-루틴-응집-수준"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-루틴-응집-수준"}},[i._v("#")]),i._v(" 3. 루틴 응집 수준")]),i._v(" "),n("ul",[n("li",[i._v("우연한 응집")]),i._v(" "),n("li",[i._v("논리적 응집")]),i._v(" "),n("li",[i._v("시점 기준 응집")]),i._v(" "),n("li",[i._v("절차적 응집")]),i._v(" "),n("li",[i._v("소통적 응집")]),i._v(" "),n("li",[i._v("순차적 응집")]),i._v(" "),n("li",[i._v("기능적 응집 (단일 책임 원칙) !!!\n상속은 Has a (X)구조가 아닌 Is a (O) 구조")])]),i._v(" "),n("h2",{attrs:{id:"객체지향-설계"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#객체지향-설계"}},[i._v("#")]),i._v(" 객체지향 설계")]),i._v(" "),n("h3",{attrs:{id:"_1-객체지향-설계-5대-원칙-solid"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-객체지향-설계-5대-원칙-solid"}},[i._v("#")]),i._v(" 1. 객체지향 설계 5대 원칙 ( SOLID )")]),i._v(" "),n("ul",[n("li",[n("strong",[i._v("OCP")]),i._v(" : Open-Closed Principle (개방-폐쇄의 원칙)\n( “상속에는 열려있어야 하고 변경에는 닫혀있어야한다.” )")]),i._v(" "),n("li",[n("strong",[i._v("SRP")]),i._v(" : Single-Responsibility Principle (단일 책임의 원칙)")]),i._v(" "),n("li",[n("strong",[i._v("DIP")]),i._v(" : Dependency Inversion Principle (의존 역전의 원칙)")]),i._v(" "),n("li",[n("strong",[i._v("ISP")]),i._v(" : Interface Segregation Principle (인터페이스 분리의 원칙)")]),i._v(" "),n("li",[n("strong",[i._v("LSP")]),i._v(" : Liskov Substitution Principle (리스코프의 대체 원칙)")])]),i._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[i._v("**SOLID 개념 정리**\n1. 단일 책임 원칙  Single Responsibility Principle\n    - 한가지 기능의 변경이 다른 곳에 영향을 주어서는 안된다.\n2. 개방 / 폐쇄 원칙  Open / Closed Principle\n    - 개체는 확장 가능성을 열어두고, 수정 가능성은 닫아야 한다. (Extend)\n3. 리스코프 치환 원칙 Liskov Substitution Principle\n    - 개체의 추상화 -어떤 타입에서 파생된 객체가 있다면 이 타입을 사용하는 코드는 변경하지 않아야한다.(abstract)\n4. 인터페이스 분리 원칙 Interface Segrefation Principle\n   - 외부 인터페이스를 통해서 객체끼리 소통한다.\n5. 의존성 역전 원칙 Dependency Inversion Principle\n   - 상위 수준 모듈은 하위 수준 모듈에 의존해서는 안된다. 이 둘읕 추상화에 의존해야 한다.\n\nDRY  규칙\n- 반복하지 마라. !! (Do not Repeat Yourself)\n")])])]),n("h3",{attrs:{id:"_2-객체지향-4대-원칙"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-객체지향-4대-원칙"}},[i._v("#")]),i._v(" 2. 객체지향 4대 원칙")]),i._v(" "),n("ul",[n("li",[i._v("캡슐화 (Encapsulation) - 정보 은닉")]),i._v(" "),n("li",[i._v("다형성 (Polymorphism) - 사용자 편의")]),i._v(" "),n("li",[i._v("상속 (Inheritance) - 재사용")]),i._v(" "),n("li",[i._v("추상화(Abstraction) - 모델링\n(상속을 통한 추상화, 인터페이스를 통한 추상화, 다형성을 추상화)")])]),i._v(" "),n("h3",{attrs:{id:"_3-solid-개념"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-solid-개념"}},[i._v("#")]),i._v(" 3. SOLID 개념")]),i._v(" "),n("ul",[n("li",[i._v("단일 책임 원칙 Single Responsibility Principle\n"),n("ul",[n("li",[i._v("한가지 기능의 변경이 다른 곳에 영향을 주어서는 안된다.")])])]),i._v(" "),n("li",[i._v("개방 / 폐쇄 원칙 Open / Closed Principle\n"),n("ul",[n("li",[i._v("개체는 확장 가능성을 열어두고, 수정 가능성은 닫아야 한다. (Extend)")])])]),i._v(" "),n("li",[i._v("리스코프 치환 원칙 Liskov Substitution Principle\n"),n("ul",[n("li",[i._v("개체의 추상화 - 어떤 타입에서 파생된 객체가 있다면 이 타입을 사용하는 코드는 변경하지 않아야 한다. (abstract)")])])]),i._v(" "),n("li",[i._v("인터페이스 분리 원칙 Interface Segrefation Principle\n"),n("ul",[n("li",[i._v("외부 인터페이스를 통해서 객체끼리 소통한다.")])])]),i._v(" "),n("li",[i._v("의존성 역전 원칙 Dependency Inversion Principle\n"),n("ul",[n("li",[i._v("상위 수준 모듈은 하위 수준 모듈에 의존해서는 안된다. 이 둘읕 추상화에 의존해야 한다.")])])])]),i._v(" "),n("h3",{attrs:{id:"_2-객체지향-4대-원칙-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-객체지향-4대-원칙-2"}},[i._v("#")]),i._v(" 2. 객체지향 4대 원칙")]),i._v(" "),n("ul",[n("li",[i._v("캡슐화 (Encapsulation) - 정보 은닉")]),i._v(" "),n("li",[i._v("다형성 (Polymorphism) - 사용자 편의")]),i._v(" "),n("li",[i._v("상속 (Inheritance) - 재사용")]),i._v(" "),n("li",[i._v("추상화(Abstraction) - 모델링\n(상속을 통한 추상화, 인터페이스를 통한 추상화, 다형성을 추상화)")])]),i._v(" "),n("h3",{attrs:{id:"_3-solid-개념-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-solid-개념-2"}},[i._v("#")]),i._v(" 3. SOLID 개념")]),i._v(" "),n("ul",[n("li",[i._v("단일 책임 원칙 Single Responsibility Principle\n"),n("ul",[n("li",[i._v("한가지 기능의 변경이 다른 곳에 영향을 주어서는 안된다.")])])]),i._v(" "),n("li",[i._v("개방 / 폐쇄 원칙 Open / Closed Principle\n"),n("ul",[n("li",[i._v("개체는 확장 가능성을 열어두고, 수정 가능성은 닫아야 한다. (Extend)")])])]),i._v(" "),n("li",[i._v("리스코프 치환 원칙 Liskov Substitution Principle\n"),n("ul",[n("li",[i._v("개체의 추상화 - 어떤 타입에서 파생된 객체가 있다면 이 타입을 사용하는 코드는 변경하지 않아야 한다. (abstract)")])])]),i._v(" "),n("li",[i._v("인터페이스 분리 원칙 Interface Segrefation Principle\n"),n("ul",[n("li",[i._v("외부 인터페이스를 통해서 객체끼리 소통한다.")])])]),i._v(" "),n("li",[i._v("의존성 역전 원칙 Dependency Inversion Principle\n"),n("ul",[n("li",[i._v("상위 수준 모듈은 하위 수준 모듈에 의존해서는 안된다. 이 둘읕 추상화에 의존해야 한다.### 2. 객체지향 4대 원칙")])])]),i._v(" "),n("li",[i._v("캡슐화 (Encapsulation) - 정보 은닉")]),i._v(" "),n("li",[i._v("다형성 (Polymorphism) - 사용자 편의")]),i._v(" "),n("li",[i._v("상속 (Inheritance) - 재사용")]),i._v(" "),n("li",[i._v("추상화(Abstraction) - 모델링\n(상속을 통한 추상화, 인터페이스를 통한 추상화, 다형성을 추상화)")])]),i._v(" "),n("h3",{attrs:{id:"_3-solid-개념-3"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-solid-개념-3"}},[i._v("#")]),i._v(" 3. SOLID 개념")]),i._v(" "),n("ul",[n("li",[i._v("단일 책임 원칙 Single Responsibility Principle\n"),n("ul",[n("li",[i._v("한가지 기능의 변경이 다른 곳에 영향을 주어서는 안된다.")])])]),i._v(" "),n("li",[i._v("개방 / 폐쇄 원칙 Open / Closed Principle\n"),n("ul",[n("li",[i._v("개체는 확장 가능성을 열어두고, 수정 가능성은 닫아야 한다. (Extend)")])])]),i._v(" "),n("li",[i._v("리스코프 치환 원칙 Liskov Substitution Principle\n"),n("ul",[n("li",[i._v("개체의 추상화 - 어떤 타입에서 파생된 객체가 있다면 이 타입을 사용하는 코드는 변경하지 않아야 한다. (abstract)")])])]),i._v(" "),n("li",[i._v("인터페이스 분리 원칙 Interface Segrefation Principle\n"),n("ul",[n("li",[i._v("외부 인터페이스를 통해서 객체끼리 소통한다.")])])]),i._v(" "),n("li",[i._v("의존성 역전 원칙 Dependency Inversion Principle\n"),n("ul",[n("li",[i._v("상위 수준 모듈은 하위 수준 모듈에 의존해서는 안된다. 이 둘읕 추상화에 의존해야 한다.### 2. 객체지향 4대 원칙")])])]),i._v(" "),n("li",[i._v("캡슐화 (Encapsulation) - 정보 은닉")]),i._v(" "),n("li",[i._v("다형성 (Polymorphism) - 사용자 편의")]),i._v(" "),n("li",[i._v("상속 (Inheritance) - 재사용")]),i._v(" "),n("li",[i._v("추상화(Abstraction) - 모델링\n(상속을 통한 추상화, 인터페이스를 통한 추상화, 다형성을 추상화)")])]),i._v(" "),n("h3",{attrs:{id:"_3-solid-개념-4"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-solid-개념-4"}},[i._v("#")]),i._v(" 3. SOLID 개념")]),i._v(" "),n("ul",[n("li",[i._v("단일 책임 원칙 Single Responsibility Principle\n"),n("ul",[n("li",[i._v("한가지 기능의 변경이 다른 곳에 영향을 주어서는 안된다.")])])]),i._v(" "),n("li",[i._v("개방 / 폐쇄 원칙 Open / Closed Principle\n"),n("ul",[n("li",[i._v("개체는 확장 가능성을 열어두고, 수정 가능성은 닫아야 한다. (Extend)")])])]),i._v(" "),n("li",[i._v("리스코프 치환 원칙 Liskov Substitution Principle\n"),n("ul",[n("li",[i._v("개체의 추상화 - 어떤 타입에서 파생된 객체가 있다면 이 타입을 사용하는 코드는 변경하지 않아야 한다. (abstract)")])])]),i._v(" "),n("li",[i._v("인터페이스 분리 원칙 Interface Segrefation Principle\n"),n("ul",[n("li",[i._v("외부 인터페이스를 통해서 객체끼리 소통한다.")])])]),i._v(" "),n("li",[i._v("의존성 역전 원칙 Dependency Inversion Principle\n"),n("ul",[n("li",[i._v("상위 수준 모듈은 하위 수준 모듈에 의존해서는 안된다. 이 둘읕 추상화에 의존해야 한다.### 2. 객체지향 4대 원칙")])])]),i._v(" "),n("li",[i._v("캡슐화 (Encapsulation) - 정보 은닉")]),i._v(" "),n("li",[i._v("다형성 (Polymorphism) - 사용자 편의")]),i._v(" "),n("li",[i._v("상속 (Inheritance) - 재사용")]),i._v(" "),n("li",[i._v("추상화(Abstraction) - 모델링\n(상속을 통한 추상화, 인터페이스를 통한 추상화, 다형성을 추상화)")])]),i._v(" "),n("h3",{attrs:{id:"_3-solid-개념-5"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-solid-개념-5"}},[i._v("#")]),i._v(" 3. SOLID 개념")]),i._v(" "),n("ul",[n("li",[i._v("단일 책임 원칙 Single Responsibility Principle\n"),n("ul",[n("li",[i._v("한가지 기능의 변경이 다른 곳에 영향을 주어서는 안된다.")])])]),i._v(" "),n("li",[i._v("개방 / 폐쇄 원칙 Open / Closed Principle\n"),n("ul",[n("li",[i._v("개체는 확장 가능성을 열어두고, 수정 가능성은 닫아야 한다. (Extend)")])])]),i._v(" "),n("li",[i._v("리스코프 치환 원칙 Liskov Substitution Principle\n"),n("ul",[n("li",[i._v("개체의 추상화 - 어떤 타입에서 파생된 객체가 있다면 이 타입을 사용하는 코드는 변경하지 않아야 한다. (abstract)")])])]),i._v(" "),n("li",[i._v("인터페이스 분리 원칙 Interface Segrefation Principle\n"),n("ul",[n("li",[i._v("외부 인터페이스를 통해서 객체끼리 소통한다.")])])]),i._v(" "),n("li",[i._v("의존성 역전 원칙 Dependency Inversion Principle\n"),n("ul",[n("li",[i._v("상위 수준 모듈은 하위 수준 모듈에 의존해서는 안된다. 이 둘읕 추상화에 의존해야 한다.### 2. 객체지향 4대 원칙")])])]),i._v(" "),n("li",[i._v("캡슐화 (Encapsulation) - 정보 은닉")]),i._v(" "),n("li",[i._v("다형성 (Polymorphism) - 사용자 편의")]),i._v(" "),n("li",[i._v("상속 (Inheritance) - 재사용")]),i._v(" "),n("li",[i._v("추상화(Abstraction) - 모델링\n(상속을 통한 추상화, 인터페이스를 통한 추상화, 다형성을 추상화)")])]),i._v(" "),n("h3",{attrs:{id:"_3-solid-개념-6"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-solid-개념-6"}},[i._v("#")]),i._v(" 3. SOLID 개념")]),i._v(" "),n("ul",[n("li",[i._v("단일 책임 원칙 Single Responsibility Principle\n"),n("ul",[n("li",[i._v("한가지 기능의 변경이 다른 곳에 영향을 주어서는 안된다.")])])]),i._v(" "),n("li",[i._v("개방 / 폐쇄 원칙 Open / Closed Principle\n"),n("ul",[n("li",[i._v("개체는 확장 가능성을 열어두고, 수정 가능성은 닫아야 한다. (Extend)")])])]),i._v(" "),n("li",[i._v("리스코프 치환 원칙 Liskov Substitution Principle\n"),n("ul",[n("li",[i._v("개체의 추상화 - 어떤 타입에서 파생된 객체가 있다면 이 타입을 사용하는 코드는 변경하지 않아야 한다. (abstract)")])])]),i._v(" "),n("li",[i._v("인터페이스 분리 원칙 Interface Segrefation Principle\n"),n("ul",[n("li",[i._v("외부 인터페이스를 통해서 객체끼리 소통한다.")])])]),i._v(" "),n("li",[i._v("의존성 역전 원칙 Dependency Inversion Principle\n"),n("ul",[n("li",[i._v("상위 수준 모듈은 하위 수준 모듈에 의존해서는 안된다. 이 둘읕 추상화에 의존해야 한다.### 2. 객체지향 4대 원칙")])])]),i._v(" "),n("li",[i._v("캡슐화 (Encapsulation) - 정보 은닉")]),i._v(" "),n("li",[i._v("다형성 (Polymorphism) - 사용자 편의")]),i._v(" "),n("li",[i._v("상속 (Inheritance) - 재사용")]),i._v(" "),n("li",[i._v("추상화(Abstraction) - 모델링\n(상속을 통한 추상화, 인터페이스를 통한 추상화, 다형성을 추상화)")])]),i._v(" "),n("h3",{attrs:{id:"_3-solid-개념-7"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-solid-개념-7"}},[i._v("#")]),i._v(" 3. SOLID 개념")]),i._v(" "),n("ul",[n("li",[i._v("단일 책임 원칙 Single Responsibility Principle\n"),n("ul",[n("li",[i._v("한가지 기능의 변경이 다른 곳에 영향을 주어서는 안된다.")])])]),i._v(" "),n("li",[i._v("개방 / 폐쇄 원칙 Open / Closed Principle\n"),n("ul",[n("li",[i._v("개체는 확장 가능성을 열어두고, 수정 가능성은 닫아야 한다. (Extend)")])])]),i._v(" "),n("li",[i._v("리스코프 치환 원칙 Liskov Substitution Principle\n"),n("ul",[n("li",[i._v("개체의 추상화 - 어떤 타입에서 파생된 객체가 있다면 이 타입을 사용하는 코드는 변경하지 않아야 한다. (abstract)")])])]),i._v(" "),n("li",[i._v("인터페이스 분리 원칙 Interface Segrefation Principle\n"),n("ul",[n("li",[i._v("외부 인터페이스를 통해서 객체끼리 소통한다.")])])]),i._v(" "),n("li",[i._v("의존성 역전 원칙 Dependency Inversion Principle\n"),n("ul",[n("li",[i._v("상위 수준 모듈은 하위 수준 모듈에 의존해서는 안된다. 이 둘읕 추상화에 의존해야 한다.### 2. 객체지향 4대 원칙")])])]),i._v(" "),n("li",[i._v("캡슐화 (Encapsulation) - 정보 은닉")]),i._v(" "),n("li",[i._v("다형성 (Polymorphism) - 사용자 편의")]),i._v(" "),n("li",[i._v("상속 (Inheritance) - 재사용")]),i._v(" "),n("li",[i._v("추상화(Abstraction) - 모델링\n(상속을 통한 추상화, 인터페이스를 통한 추상화, 다형성을 추상화)")])]),i._v(" "),n("h3",{attrs:{id:"_3-solid-개념-8"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-solid-개념-8"}},[i._v("#")]),i._v(" 3. SOLID 개념")]),i._v(" "),n("ul",[n("li",[i._v("단일 책임 원칙 Single Responsibility Principle\n"),n("ul",[n("li",[i._v("한가지 기능의 변경이 다른 곳에 영향을 주어서는 안된다.")])])]),i._v(" "),n("li",[i._v("개방 / 폐쇄 원칙 Open / Closed Principle\n"),n("ul",[n("li",[i._v("개체는 확장 가능성을 열어두고, 수정 가능성은 닫아야 한다. (Extend)")])])]),i._v(" "),n("li",[i._v("리스코프 치환 원칙 Liskov Substitution Principle\n"),n("ul",[n("li",[i._v("개체의 추상화 - 어떤 타입에서 파생된 객체가 있다면 이 타입을 사용하는 코드는 변경하지 않아야 한다. (abstract)")])])]),i._v(" "),n("li",[i._v("인터페이스 분리 원칙 Interface Segrefation Principle\n"),n("ul",[n("li",[i._v("외부 인터페이스를 통해서 객체끼리 소통한다.")])])]),i._v(" "),n("li",[i._v("의존성 역전 원칙 Dependency Inversion Principle\n"),n("ul",[n("li",[i._v("상위 수준 모듈은 하위 수준 모듈에 의존해서는 안된다. 이 둘읕 추상화에 의존해야 한다.")])])])])])}),[],!1,null,null,null);l.default=_.exports}}]);