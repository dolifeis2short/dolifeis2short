(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{397:function(i,t,e){"use strict";e.r(t);var n=e(48),a=Object(n.a)({},(function(){var i=this,t=i.$createElement,e=i._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":i.$parent.slotKey}},[e("h1",{attrs:{id:"알고리즘"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#알고리즘"}},[i._v("#")]),i._v(" 알고리즘")]),i._v(" "),e("ul",[e("li",[i._v("구축의 목표와, 그 목표를 효과적으로 달성하기 위한 데이터 스킴")])]),i._v(" "),e("div",{staticClass:"language-text extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[i._v("* Public : 흐름 (위임 메소드, 조합 메소드)\n- 구현에 대한 기술을 하지 않는다.\n\n* Protected, Private\n- 기술, 이야기의 의미를 서술한다.\n\n* 커뮤니케이션은 Diagram\n\n* Class 는 명사\n* Method 는 동사\n")])])]),e("h2",{attrs:{id:"_1-설계-레벨"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-설계-레벨"}},[i._v("#")]),i._v(" 1. 설계 레벨")]),i._v(" "),e("h3",{attrs:{id:"설계-수준"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#설계-수준"}},[i._v("#")]),i._v(" 설계 수준")]),i._v(" "),e("ul",[e("li",[i._v("S/W 시스템 설계")]),i._v(" "),e("li",[i._v("Sub 시스템 설계")]),i._v(" "),e("li",[i._v("모듈 / 패키지 설계")]),i._v(" "),e("li",[i._v("컴포넌트 설계")]),i._v(" "),e("li",[i._v("클래스 분화 설계")]),i._v(" "),e("li",[i._v("루틴 분화 설계")])]),i._v(" "),e("h3",{attrs:{id:"설계"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#설계"}},[i._v("#")]),i._v(" 설계")]),i._v(" "),e("ul",[e("li",[i._v("반복 / 분할 정복 설계")]),i._v(" "),e("li",[i._v("상향 / 하향적 설계")]),i._v(" "),e("li",[i._v("프로토 타입 설계")]),i._v(" "),e("li",[i._v("협력적 설계")])]),i._v(" "),e("h3",{attrs:{id:"루틴-응집-수준"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#루틴-응집-수준"}},[i._v("#")]),i._v(" 루틴 응집 수준")]),i._v(" "),e("ul",[e("li",[i._v("우연한 응집")]),i._v(" "),e("li",[i._v("논리적 응집")]),i._v(" "),e("li",[i._v("시점 기준 응집")]),i._v(" "),e("li",[i._v("절차적 응집")]),i._v(" "),e("li",[i._v("소통적 응집")]),i._v(" "),e("li",[i._v("순차적 응집")]),i._v(" "),e("li",[i._v("기능적 응집 (단일 책임 원칙) !!!\n상속은 Has a (X)구조가 아닌 Is a (O) 구조")])]),i._v(" "),e("h2",{attrs:{id:"_2-객체지향-설계"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-객체지향-설계"}},[i._v("#")]),i._v(" 2. 객체지향 설계")]),i._v(" "),e("h3",{attrs:{id:"객체지향-설계-5대-원칙-solid"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#객체지향-설계-5대-원칙-solid"}},[i._v("#")]),i._v(" 객체지향 설계 5대 원칙 ( SOLID )")]),i._v(" "),e("ul",[e("li",[e("strong",[i._v("OCP")]),i._v(" : Open-Closed Principle (개방-폐쇄의 원칙)\n( “상속에는 열려있어야 하고 변경에는 닫혀있어야한다.” )")]),i._v(" "),e("li",[e("strong",[i._v("SRP")]),i._v(" : Single-Responsibility Principle (단일 책임의 원칙)")]),i._v(" "),e("li",[e("strong",[i._v("DIP")]),i._v(" : Dependency Inversion Principle (의존 역전의 원칙)")]),i._v(" "),e("li",[e("strong",[i._v("ISP")]),i._v(" : Interface Segregation Principle (인터페이스 분리의 원칙)")]),i._v(" "),e("li",[e("strong",[i._v("LSP")]),i._v(" : Liskov Substitution Principle (리스코프의 대체 원칙)")])]),i._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[i._v("**SOLID 개념 정리**\n1. 단일 책임 원칙  Single Responsibility Principle\n    - 한가지 기능의 변경이 다른 곳에 영향을 주어서는 안된다.\n2. 개방 / 폐쇄 원칙  Open / Closed Principle\n    - 개체는 확장 가능성을 열어두고, 수정 가능성은 닫아야 한다. (Extend)\n3. 리스코프 치환 원칙 Liskov Substitution Principle\n    - 개체의 추상화 -어떤 타입에서 파생된 객체가 있다면 이 타입을 사용하는 코드는 변경하지 않아야한다.(abstract)\n4. 인터페이스 분리 원칙 Interface Segrefation Principle\n   - 외부 인터페이스를 통해서 객체끼리 소통한다.\n5. 의존성 역전 원칙 Dependency Inversion Principle\n   - 상위 수준 모듈은 하위 수준 모듈에 의존해서는 안된다. 이 둘읕 추상화에 의존해야 한다.\n\nDRY  규칙\n- 반복하지 마라. !! (Do not Repeat Yourself)\n")])])]),e("h3",{attrs:{id:"객체지향-4대-원칙"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#객체지향-4대-원칙"}},[i._v("#")]),i._v(" 객체지향 4대 원칙")]),i._v(" "),e("ul",[e("li",[i._v("캡슐화 (Encapsulation) - 정보 은닉")]),i._v(" "),e("li",[i._v("다형성 (Polymorphism) - 사용자 편의")]),i._v(" "),e("li",[i._v("상속 (Inheritance) - 재사용")]),i._v(" "),e("li",[i._v("추상화(Abstraction) - 모델링\n(상속을 통한 추상화, 인터페이스를 통한 추상화, 다형성을 추상화)")])]),i._v(" "),e("h3",{attrs:{id:"solid-개념"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#solid-개념"}},[i._v("#")]),i._v(" SOLID 개념")]),i._v(" "),e("ul",[e("li",[i._v("단일 책임 원칙 Single Responsibility Principle\n"),e("ul",[e("li",[i._v("한가지 기능의 변경이 다른 곳에 영향을 주어서는 안된다.")])])]),i._v(" "),e("li",[i._v("개방 / 폐쇄 원칙 Open / Closed Principle\n"),e("ul",[e("li",[i._v("개체는 확장 가능성을 열어두고, 수정 가능성은 닫아야 한다. (Extend)")])])]),i._v(" "),e("li",[i._v("리스코프 치환 원칙 Liskov Substitution Principle\n"),e("ul",[e("li",[i._v("개체의 추상화 - 어떤 타입에서 파생된 객체가 있다면 이 타입을 사용하는 코드는 변경하지 않아야 한다. (abstract)")])])]),i._v(" "),e("li",[i._v("인터페이스 분리 원칙 Interface Segrefation Principle\n"),e("ul",[e("li",[i._v("외부 인터페이스를 통해서 객체끼리 소통한다.")])])]),i._v(" "),e("li",[i._v("의존성 역전 원칙 Dependency Inversion Principle\n"),e("ul",[e("li",[i._v("상위 수준 모듈은 하위 수준 모듈에 의존해서는 안된다. 이 둘읕 추상화에 의존해야 한다.")])])])])])}),[],!1,null,null,null);t.default=a.exports}}]);